# -*- org-src-preserve-indentation: t; org-edit-src-content: 0; org-confirm-babel-evaluate: nil; -*-
# NOTE: `org-src-preserve-indentation: t; org-edit-src-content: 0;` are options to ensure indentations are preserved for export to ipynb.
# NOTE: `org-confirm-babel-evaluate: nil;` means no confirmation will be requested before executing code blocks

#+TITLE: Phase Equilibrium Modelling
* Introduction
Not all samples had corresponding thin sections from which a degree of serpentinization could be inferred. Instead, proxies can be used to infer the degree of serpentinization:
- Color
- Density \citep{Otofuji2021,Miller1997}
* Color
** Reading the Data
Images of hand sample cut faces were taken under similar lighting and camera exposure conditions. These were then cropped to rectangles to remove the background and non-flat regions, and then named by sample, slice index and face in =../DATASETS/PHYSICAL/sample_imagery/=. Each sample can be represented by multiple images, and opposing faces (of a singular cut) are not repeated.

The images are first loaded as RGB arrays, which are split into the separate bands before a whole-image mean (and standard deviation) are computed. Since this is a computationally expensive process, the results are stored to disk in the file =./local_data/colors.csv=, which is read into the kernel if already present (i.e. to rerun the code, just delete that file).

#+BEGIN_SRC python :session py
from PIL import Image
import os
import numpy as np
import pandas as pd

color_datafile = "./local_data/colors.csv"
samples_dir = "../DATASETS/PHYSICAL/sample_imagery/"

if os.path.exists(color_datafile):
    print(f"Reading data from existing file {color_datafile}")
    color_df = pd.read_csv(color_datafile,index_col=0)
else:
    print(f"Regenerating data from images in folder {samples_dir}")
    data = dict()
    for sample_face in os.listdir(samples_dir):
        sample = sample_face.split(".")[0]
        if sample not in data:
            data[sample] = dict(R=[],G=[],B=[],val=[])
        img = Image.open(os.path.join(samples_dir,sample_face))
        img_arr = np.array(img)
        flat_arr = np.reshape(img_arr,(img_arr.shape[0]*img_arr.shape[1],img_arr.shape[2]))
        if img.mode == "RGBA":
            flat_arr = flat_arr[flat_arr[:,3]==255]
        R,G,B = flat_arr[:,0],flat_arr[:,1],flat_arr[:,2]
        val = flat_arr[:,:3].mean(axis=1)

        data[sample]["R"].extend(list(R))
        data[sample]["G"].extend(list(G))
        data[sample]["B"].extend(list(B))
        data[sample]["val"].extend(list(val))

    aggregated_data = dict()
    for sample in data:
        aggregated_data[sample] = dict()
        for c in ["R","G","B","val"]:
            sample_c_data = data[sample][c]
            aggregated_data[sample][c] = np.mean(sample_c_data)
            aggregated_data[sample][f"{c}_stdev"] = np.std(sample_c_data)

    color_df = pd.DataFrame().from_dict(aggregated_data).T
    color_df.to_csv(color_datafile)
#+END_SRC

#+RESULTS:
* Density
** Loading the Data
Mass and volume measurement results are stored in =../DATASETS/PHYSICAL/masses_volumes.csv=. Multiple measurements were made for each property, with the measurement index being appended to the column names.
- Masses were all measured $\geq$3 times on 19/2/2024
- First set of volumes (using the volume difference method after submergence in water): 19/2/2024
- Second set of volumes: 21/2/2024 (the time gap permitted drying of the samples)
- Third set of volumes: 27/2/2024
- Fourth set of volumes: 29/2/2024


#+BEGIN_SRC python :session py
df = pd.read_csv("../DATASETS/PHYSICAL/masses_volumes.csv",index_col=0)

for i in range(1,int(len(volume_cols)/2)+1):
    vol_start = df[f"vol_water_{i:d}"]
    vol_end = df[f"vol_water_sample_{i:d}"]
    vol_sample = vol_end - vol_start
    df[f"vol_{i:d}"] = vol_sample

# Clean the dataframe of irrelevant columns for density calculation (in case df is to be displayed).
for c in df.columns:
    if "_water_" in c or "cylinder" in c:
        df.drop(c,inplace=True,axis=1)
#+END_SRC

#+RESULTS:

The mass and volume data are first summarized in a mean and uncertainty (half the range divided by the mean), and then density computed (alongside density uncertain as a sum of the mass and volume uncertainties).

#+BEGIN_SRC python :session py
vol_cols = [c for c in df.columns if "vol" in c]
mass_cols = [c for c in df.columns if "mass" in c]

rowwise_half_range_arr = lambda data_arr : ((np.nanmax(data_arr,axis=1) - np.nanmin(data_arr,axis=1))/2)

vol_df = df[vol_cols]
mass_df = df[mass_cols]
vol_mean = np.nanmean(vol_df,axis=1)
vol_uncert = rowwise_half_range_arr(vol_df)/vol_mean
mass_mean = np.nanmean(mass_df,axis=1)
mass_uncert = rowwise_half_range_arr(mass_df)/mass_mean
density_mean = mass_mean/vol_mean
density_uncert = mass_uncert + vol_uncert
#+END_SRC

#+RESULTS:

* Density vs Color Plots
With density and color both intending to be used to represent the degree of serpentinisation, a relation should be present when the two are scatterplotted against each other. The color parameter to investigate will be the value, but can be changed to a color band if desired.

#+BEGIN_SRC python :session py
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from sklearn.metrics import r2_score

linear_func = lambda x,a,b : a*x + b

color_param = "val" # or one out of {"R","G","B"}

color_df = color_df.reindex(mass_df.index)

fig,ax = plt.subplots()
x = color_df[color_param].to_list()
y = list(density_mean) # rho (density)
ax.scatter(x,y,marker="+",c="r",zorder=1000)
ax.errorbar(x,y,xerr=color_df[f"{color_param}_stdev"],yerr=density_uncert,linestyle="none",marker="+")
[ax.text(xi,yi,sample) for xi,yi,sample in zip(x,y,mass_df.index)]

popt,pcov = curve_fit(linear_func,x,y)
model_rho = linear_func(np.array(x),*popt)
r2 = r2_score(y,model_rho)
ax.plot(x,model_rho)
ax.set_title(f"Fit: $\\rho$ = {popt[0]:.5f} * x + {popt[1]:.5f}; $r^2$ = {r2:.2f}")
ax.set_xlabel(color_param)
ax.set_ylabel("Density")
plt.show()
#+END_SRC

#+RESULTS:
: None

Assuming a linear relationship, there seems to be a decrease in density as value/brightness increases, which makes sense as serpentinisation (accompanied by silica increase) produces lighter minerals (in both density and color) compared to mantle minerals: i.e. olivine and pyroxene \to serpentinite.
